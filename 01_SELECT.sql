/*
 * SECLECT (DML 또는 DQL) : 조회
 * 
 * - 데이터를 조회(SELECT)하면 조건에 맞는 행들이 조회됨.
 * 이 때, 조회된 행들의 집합을 "RESULT SET" 이라고 한다.
 * - RESULT SET은 0개 이상의 행을 포함할 수 있다.
 * 왜 0개? 조건에 맞는 행이 없을 수도 있어서.
 * 
 * 
 * */



-- [작성법]
-- SELECT 컬럼명 FROM 테이블명;
--> 테이블의 특정 컬럼을 조회하겠다.

SELECT * FROM EMPLOYEE; -- 테이블의 특정 컬럼을 조회하기 위한 기본 구조
-- '*' : ALL, 모든, 전부
--> EMPLOYEE 테이블의 모든 컬럼을 조회하겠다.

-- EMPLOYEE 테이블에서 사번, 직원이름, 휴대전화번호 컬럼만 조회
 SELECT EMP_ID , EMP_NAME, PHONE FROM EMPLOYEE; -- 특정 컬럼만 조회
------------------------------------------------------------------------------------------------------------------

-- <컬럼 값 산술 연산>
-- 컬럼 값 : 테이블 내 한 칸 (== 한 셀)에 작성된 값 (DATA)

-- EMPLOYEE 테이블에서 모든 사원의 사번, 이름, 급여, 연봉 조회
 SELECT EMP_ID , EMP_NAME , SALARY, SALARY * 12 FROM EMPLOYEE; -- 급여 * 12로 연봉을 계산

SELECT EMP_NAME + 10 FROM EMPLOYEE;
-- SQL Error [1722] [42000]: ORA-01722: 수치가 부적합합니다
-- 산술연산은 숫자 타입(NUMBER 타입)만 가능하다!

SELECT '같음'
FROM DUAL -- DUAL 은 보통 테스트나 간단한 계산을 위해 사용되는 더미 테이블입니다.
WHERE 1 = '1';

-- 문자열 타입이어도 저장된 값이 숫자면 자동으로 형변환하여 연산 가능
SELECT EMP_ID + 10 FROM EMPLOYEE;  
--------------------------------------------------------------------------------------------------------

-- 날짜(DATE) 타입 조회

-- EMPLOYEE 테이블에서 이름, 입사일, 오늘 날짜 조회


SELECT EMP_NAME, HIRE_DATE, SYSDATE
FROM EMPLOYEE;
-- 이 쿼리는 EMPLOYEE 테이블에서 직원의 이름 (EMP_NAME),입사일 (HIRE_DATE),
-- 그리고 현재 시스템 날짜(SYSDATE)를 조회합니다. SYSDATE는
-- 데이터베이스 서버의 현재 시간을 반환하는 상수입니다.

-- 2024-10-08 11:09:19.000
-- SYSDATE : 시스템상의 현재 시간(날짜)를 나타내는 상수

SELECT SYSDATE
FROM DUAL;
-- DUAL 테이블은 특별한 데이터를 조회할 필요 없이 간단한 상수나 함수를 실행할 때 사용되는
-- 가상 테이블입니다. 이 쿼리는 SYSDATE를 사용해 시스템의 현재 날짜와 시간을 반환합니다.



-- 날짜 + 산술연산 ( + , - )

-- 날짜에 대한 + 또는 - 연산을 사용하면 일 단위로 날짜를 조정할 수 있습니다.
-- 예를 들어 SYSDATE + 1 은 현재 날짜에서 하루를 더한 값이고, SYSDATE -1 은 하루를 뺀 값입니다.

SELECT SYSDATE - 1, SYSDATE, SYSDATE + 1
FROM DUAL;


-- SYSDATE - 1 : 현재 날짜보다 하루 전
-- SYSDATE : 현재 날짜
-- SYSDATE + 1 : 현재 날짜보다 하루 후

-- SYSATE : 시스템의 현재 날짜와 시간을 반환합니다.
-- 날짜 연산: 날짜에 + 또는 - 연산을 하면 일 단위로 더하거나 뺄 수 있습니다.
--------------------------------------------------------------------------------------------------------

-- <컬럼 별칭 지정>

/* 컬럼명 AS 별칭 : 별칭 띄어쓰기 x, 특수문자 x, 문자만 o
 * 
 * 컬럼명 AS "별칭" : 별칭 띄어쓰기 o, 특수문자 o, 문자만 o
 * 
 * AS 생략 가능 
 * 
 * */
SELECT SYSDATE - 1 "하루 전", SYSDATE AS 현재시간, SYSDATE + 1 내일 FROM DUAL;
-- 컬럼에 별칭을 부여해 가독성을 높임

-- SYSTEM -1 : "하루 전"
-- 현재 날짜에서 하루 전을 계산하며, 결과 컬럼에 **하루 전**이라는 별칭을 부여합니다,
-- 따옴표 ""를 사용하여 별칭에 띄어쓰기를 허용했습니다.

-- SYSDATE AD 현재시간:
-- 현재 날짜와 시간을 반환하며, 현재시간이라는 별칭을 부여합니다.
-- AD 키워드를 사용해 별칭을 부여할 수 있지만, AS는 생략할 수도 있습니다.

-- SYSDTE +1 내일:
-- 현재 날짜보다 **하루 후(내일)**의 날짜를 계산하며, 내일이라는 별칭을 부여합니다.
-- AS 키워드를 생략하고 별칭을 부여한 예시입니다.

-- 중요한 포인트:
-- AS 키워드는 컬럼에 별칭을 부여할 때 사용되지만, 생략할 수 있습니다.
-- 별칭에 띄어쓰기 또는 특수문자를 포함하고 싶을 경우 " "(따옴표)를 사용해야 합니다,
-- 별칭을 부여함으로써 결과를 보다 직관적으로 읽을 수 있어 가독성이 향상 됩니다.
---------------------------------------------------------------------------------------------------------

-- JAVA 리터럴 : 값 자체를 의미  "안녕"
-- DB 리터럴 : 임의로 지정한 값을 기존 테이블에 존재하는 값처럼 사용하는 것
--> (필수) DB의 리터럴 표기법은 ''홑따옴표

SELECT EMP_NAME, SALARY, '원 입니다' FROM EMPLOYEE;
-- EMP_NAME: 직원의 이름을 조회합니다.
-- SALARY: 직원의 급여를 조회합니다.
-- '원 입니다': DB 리터럴로, 고정된 텍스트를 결과에 추가합니다. 모든 결과
-- 행마다 '원 입니다' 라는 텍스트가 추가됩니다.

-- 홑따옴표(' ')를 사용하여 리터럴을 지정합니다. SQL에서 리터럴은
-- 텍스트를 고정된 값으로 출력할 때 자주 사용됩니다.

-- 주요 포인트:
-- 리터럴의 활용: 고정된 텍스트나 숫자를 쿼리 결과에 포함시킬 수 있으며,
-- 출력 형식을 원하는 대로 조정할 수 있습니다.
-- 홑따옴표 사용: 텍스트 리터럴을 지정할 때는 항상 홑따옴표를 사용해야 합니다
-- SQL에서 따옴표가 없으면 컬럼 이름이나 함수로 인식할 수 있기 때문입니다.
-------------------------------------------------------------------------------------------------------

-- DISTINCT : 조회 시 컬럼에 포함된 중복 값을 한번만 표기
-- 주의사항 1) DISTINCT 구문은 SELECT 마다 딱 한번씩만 작성 가능
-- 주의사항 2) DISTINCT 구문은 SELECT 제일 앞에 작성되어야 한다.

SELECT DISTINCT DEPT_CODE, JOB_CODE FROM EMPLOYEE; -- 중복을 제거하고 조회할 때 사용

-- 이 SQL 쿼리는 DISTINCT 키워드를 사용하여 중복 값을 제거하고, 조회 결과에서
-- 유일한 값들만 반환하는 예시입니다. DISTINCT는 SQL에서 동일한 값이 여러 번
-- 나타나는 것을 방지할 때 사용됩니다.

-- DEPT_CODE: 직원이 속한 부서 코드를 조회합니다.
-- JOB_CODE: 직원의 직무 코드를 조회합니다,
-- DISTINCT: DEPT_CODE 와 JOB_CODE 컬럼의 중복 조합을 제거합니다. 동일
-- 한 부서와 직무 코드를 가진 직원들이 있을 때, 그 조합은 한 번만 표시됩니다.

-- DISTINCT 주의사항:
-- 1. DISTINCT는 SELECT 쿼리마다 한 번만 작성 가능합니다. 여러 컬럼에 대해
-- 중복 제거를 수행하고 싶다면, 여러 컬럼을 함께 사용해도 DISTINCT는
-- 한 번만 쓸 수 있습니다.

-- 예: SELECT DISTINCT COL1, COL2 FROM ... 는 가능하다만 SELECT DISTINCT COL1, DISTINCT COL2 ... 처럼
-- 두 번 쓸 수 없습니다

-- DISTINCT는 SELECT 문에서 제일 앞에 작성되어야 합니다. SELECT DEPT_CODE DISTINCT ... 는
--- 제일 앞이 아니기에 구문 오류가 발생합니다

-- 실행 결과:
-- 이 쿼리는 EMPLOYEE 테이블에서 중복되는 **부서 코드(DEPT_CODE)**와** 직무 코드(JOB_CODE)**의
--  조합을 제거하고, 중복되지 않은 유일한 값들만 반환합니다.

-- 요약:
-- DISTINCT는 중복 데이터를 제거하고 유일한 값만 반환할 때 사용됩니다.
-- 한 번만 사용할 수 있으면 SELECT문 맨 앞에 작성 되어야합니다.
--------------------------------------------------------------------------------------------------------

-- 이 SQL 쿼리는 EMPLOYEE 테이블에서 특정 조건을 만족하는 사원들의 데이터를
-- 조회하는 예시입니다. 두 가지 조건을 다룰 수 있는 쿼리이며, 비교 연산자와
-- WHERE 절을 사용하여 필터링된 데이터를 반환하는 방식입니다.
SELECT EMP_ID, EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE SALARY > 3000000;

-- SELECT 절:조회할 컬럼을 선택합니다. 이 경우 사번(EMP_ID), 이름
-- (EMP_NAME), 급여(SALARY), 부서 코드(DEPT_CODE)를 선택했습니다.

-- FROM 절: 데이터를 조회할 테이블을 지정합니다. 여기서는 EMPLOYEE 테
-- 이블에서 데이터를 가져옵니다.

-- WHERE 절 : 급여가 3백만 원을 초과하는 사원을 필터링합니다, 급여
-- (SALARY)가 3000000 보다 큰 값만 조회합니다.

SELECT EMP_NAME, EMP_ID, DEPT_CODE, JOB_CODE
FROM EMPLOYEE
WHERE DEPT_CODE = 'D9'; -- 여러 조건을 결합해 복잡한 필터링 가능

-- SELECT 절: 사원의 이름(EMP_NAME), 사번(EMP_ID), 부서 코드
-- (DEPT_CODE), 직급 코드(JOB_CODE)를 선택했습니다

-- FROM 절: EMPLOYEE 테이블에서 데이터를 조회합니다.

-- WHERE 절: 부서 코드가 **D9**인 사원들만 필터링하여 데이터를 조회합
-- 니다. 문자열 비교 시에는 따옴표(")를 사용합니다.

-- 비교 연산자 설명
-- > : 값이 크면 참
-- < : 값이 작으면 참
-- >= : 값이 크거나 같으면 참
-- <= : 값이 작거나 같으면 참
-- = : 값이 같으면 참
-- != : 값이 다르면 참
 
-- 요약:
-- WHERE 절을 사용해 특정 조건을 만족하는 데이터를 필터링합니다.
-- 비교 연산자를 사용하여 값을 비교하고 원하는 데이터를 추출합니다.
-- 각 절을 사용하여 쿼리를 체계적으로 구성하여 조회할 수 있습니다.
-----------------------------------------------------------------------------------------------------------------------

-- 이 SQL 쿼리들은 논리 연산자와 BETWEEN 연산자를 사용하여 다양한 조건으로
-- 데이터를 필터링하는 방법을 보여줍니다. AND, OR, BETWEEN 연산자는 여러 조건을
-- 결합하거나 범위를 지정할 때 자주 사용됩니다.

-- 1. 급여가 300만 미만 또는 500만 이상인 사원 조회 (OR 연산자)
SELECT EMP_ID, EMP_NAME, SALARY, PHONE
FROM EMPLOYEE
WHERE SALARY >= 3000000 AND SALARY < 5000000;
-- OR 연산자: 급여가 300만 미만이거나 500만 원 이상인 사원을 필터링
-- 합니다. 두 조건 중 하나라도 참이면 해당 사원을 조회합니다.

-- 2. 급여가 300만 이상 500만 미만인 사원 조회 (AND 연산자)
SELECT EMP_ID, EMP_NAME, SALARY, PHONE
FROM EMPLOYEE
WHERE SALARY < 3000000 OR SALARY >= 5000000;
-- AND 연산자: 급여가 300만 원 이상이면서 500만 원 미만인 사원을 필터링 합니다,
-- 두 조건이 모두 참일 때만 해당 사원을 조회합니다.

-- 3. BETWEEN을 사용한 범위 조회 급여가 300만 이상 600만 이하의 사원 조회
SELECT EMP_ID, EMP_NAME, SALARY, PHONE
FROM EMPLOYEE
WHERE SALARY BETWEEN 3000000 AND 6000000;
-- BETWEEN A AND B: A 이상 B 이하인 값을 조회합니다. 이 경우 300만 원
-- 이상, 600만 원 이하인 사원의 급여를 조회합니다.

-- 급여가 300만 이상 600만 이하가 아닌 사원 조회(NOT BETWEEN)
SELECT EMP_ID, EMP_NAME, SALARY, PHONE
FROM EMPLOYEE
WHERE SALARY NOT BETWEEN 3000000 AND 6000000;
-- NOT BETWEEN: BETWEEN과 반대로, 범위에 속하지 않는 값을 조회합니다.
-- 300만 원 이상 600만 원 이하가 아닌 사원을 필터링합니다.

-- 4. 날짜(DATE) 필드에 BETWEEN 사용 (1990-01-01 ~ 1999-12-31 사이에 입사한 직원 조회)
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE BETWEEN '1990-01-01' AND '1999-12-31';
--**BETWEEN**을 사용해 특정 기간(날짜 범위)에 입사한 직원들을 조회합니다.
-- 이 경우 1990년 1월 1일 부터 1999년 12월 31일 사이에 입사한 직원들을 필터링 합니다
-- 날짜 형식 : 대부분의 데이터베이스는 'YYYY-MM-DD' 형식으로 날짜를 처리합니다

-- 논리연산자 정리:
-- AND: 두 조건이 모두 참일 때 결과 반환
-- OR: 두 조건 중 하나만 참이어도 결과 반환
-- BETWEEN A AND B : A 이상 B 이하의 범위에 해당하는 결과 반환
-- NOT BETWEEN A AND B : A 이상 B 이하가 아닌 값을 반환.
-------------------------------------------------------------------------------------------------------

-- 이 SQL 쿼리들은 LIKE 연산자를 사용하여 특정 패턴을 가진 문자열 데이터를
-- 조회하는 방법을 보여줍니다. LIKE 연산자는 패턴 매칭을 위해 와일드카드(%,_)를
-- 사용하여 문자열에서 조건을 만족하는 데이터를 필터링 할 수 있습니다.

-- 1. 성이 '전'씨인 사원의 사번과 이름 조회
SELECT EMP_ID, EMP_NAME
FROM EMPLOYEE
WHERE EMP_NAME LIKE '전%';
-- LIKE '전%': 전으로 시작하는 문자열을 찾습니다. '전%'는 성이 전으로
-- 시작하는 모든 이름을 조회하는 패턴입니다.

-- 2. 전화번호가 '010' 으로 시작하지 안흔ㄴ 사원 조회
SELECT EMP_ID, EMP_NAME, PHONE
FROM EMPLOYEE
WHERE PHONE NOT LIKE '010%';
-- NOT LIKE '010%': 전화번호가 '010'으로 시작하지 않는 사원들의 정보를
-- 조회합니다 '010%'는 전화번호가 010으로 시작하는 모든 번호를 의미하고,
-- 이를 NOT_LIKE로 반전시킵니다.

SELECT EMP_NAME, EMAIL
FROM EMPLOYEE
WHERE EMAIL LIKE '____%';
-- LIKE '____%': 4글자 이상의 문자열로 시작하는 이메일 주소를 찾습니다.
-- **____**는 정확히 4개의 문자를 의미하고, 그 뒤에 어떠한 글자가 와도
-- 상관없습니다(%)

-- 4. ESCAPE 문자 사용
-- 특수 문자를 일반 문자로 인식하도록 도와주는 ESCAPE 문법을 사용하여
-- 패턴에서 _와 같은 특수 문자를 처리할 수 있습니다.
SELECT EMP_NAME, EMAIL
FROM EMPLOYEE
WHERE EMAIL LIKE '___^_%' ESCAPE '^';
-- ESCAPE '^': 패턴에서 ^ 문자를 사용해 _를 이스케이프합니다. 즉, 이메일에서
-- 앞의 3글자는 임의의 문자이고, 그 뒤에 실제_가 포함된 문자열을 찾습니다.

-- LIKE '___^_%': 첫 세글자는 임의의 문자이고, 네 번째 글자는 _로 처리
-- 합니다. 이는 실제 문자로 _를 포함하는 문자열을 찾는 방식입니다.

-- 주요포인트:
-- %:문자열 내 아무 글자나 포함해도 되는 패턴을 의미합니다.(0글자 이상)
-- 예 : 'A%'는 A로 시작하는 모든 문자열을 찾습니다.

-- _: 정확히 한 글자를 의미합니다
-- 예 : 'A_'는 A로 시작하는 두 글자 문자열을 찾습니다.

-- ESCAPE : 특수 문자를 이스케이프 처리하여, 일반 문자로 해석되게 만듭니다.
-- 예 : '___^_%' ESCAPE '^'는 _가 특수 문자가 아닌 일반 문자로 취급되게 만듭니다.
----------------------------------------------------------------------------------------------------------

-- 연습문제

-- EMPLOYEE 테이블에서
-- 이메일 '_' 앞이 4글자 이면서
-- 부서코드가 'D9' 또는 'D6' 이고 --> AND 가 OR 보다 우선순위가 높다, () 사용 가능
-- 입사일이 1990-01-01 ~ 2000-12-31 이고
-- 급여가 270만원 이상인 사원의
-- 사번, 이름, 이메일, 부서코드, 입사일, 급여 조회
SELECT * FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, EMAIL, DEPT_CODE, HIRE_DATE, SALARY
FROM EMPLOYEE
WHERE EMAIL LIKE '____#_%' ESCAPE '#'
AND (DEPT_CODE = 'D9' OR DEPT_CODE = 'D6')
AND HIRE_DATE BETWEEN '1990-01-01' AND '2000-12-31'
AND SALARY >= 2700000;


-- 연산자 우선순위

/*
 * 1. 산술 연산자( + - * / )
 * 2. 연결 연산자 ( || )
 * 3. 비교 연산자 ( > < >= <= = != <> )
 * 4. IS NULL / IS NOT NULL, LIKE, IN / NOT IN
 * 5. BETWEEN AND / NOT BETWEEN AND
 * 6. NOT (논리 연산자)
 * 7. AND
 * 8. OR
 *  
 * */


----------------------------------------------------------------------

/*
 * IN 연산자
 *  
 * 비교하려는 값과 목록에 작성된 값 중
 * 일치하는 것이 있으면 조회하는 연산자
 * 
 * [작성법]
 * WHERE 컬럼명 IN(값1, 값2, 값3 ...)
 * 
 * WHERE 컬럼명 = '값1'
 * 	  OR 컬럼명 = '값2'
 * 	  OR 컬럼명 = '값3'
 * 
 * 
 * */

-- EMPLOYEE 테이블에서
-- 부서코드가 D1, D6, D9 인 사원의
-- 사번, 이름, 부서코드 조회

SELECT EMP_ID, EMP_NAME, DEPT_CODE 
FROM EMPLOYEE
WHERE DEPT_CODE IN('D1', 'D6', 'D9'); -- 여러 값을 비교할 때 간단하게 표현

-- NOT IN
SELECT EMP_ID, EMP_NAME, DEPT_CODE 
FROM EMPLOYEE
WHERE DEPT_CODE NOT IN('D1', 'D6', 'D9') -- 12명(NULL 미포함)
OR DEPT_CODE IS NULL; -- 부서코드가 없는 2명 포함 14명


---------------------------------------------

/*
 * NULL 처리 연산자
 * 
 * JAVA 에서 NULL : 참조하는 객체가 없음을 의미
 * DB에서 NULL : 컬럼에 값이 없음을 의미하는 값
 * 
 * 1) IS NULL : NULL 인 경우 조회
 * 2) IS NOT NULL : NULL이 아닌 경우 조회
 * 
 * */


-- EMPLOYEE 테이블에서 보너스가 있는 사원의 이름, 보너스 조회
--SELECT * FROM EMPLOYEE;

SELECT EMP_NAME, BONUS
FROM EMPLOYEE
WHERE BONUS IS NOT NULL; -- 9행

-- EMPLOYEE 테이블에서 보너스가 없는 사원의 이름, 보너스 조회
SELECT EMP_NAME, BONUS
FROM EMPLOYEE
WHERE BONUS IS NOT NULL; -- 14행
-- IS NULL, IS NOT NULL 로 NULL 값을 포함하거나 제외하는 방법

----------------------------------------------------------------------------------

/*
 * ORDER BY 절
 * 
 * - SELECT문의 조회 결과 (RESULT SET)를 정렬할 때 사용하는 구문
 * 
 * ** SELECT 문 해석 시 가장 마지막에 해석된다 !! **
 * 
 * */

-- EMPLOYEE 테이블 (FROM 절)
-- 급여 오름 차순으로 (ORDER BY 절)
-- 사번, 이름, 급여 조회 (SELECT 절)
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE
ORDER BY SALARY ASC; --ASC(오름차순) 가 기본값 [ASC | DESC]


-- EMPLOYEE 테이블에서 (FROM 절)
-- 급여가 200만 이상인 사원의 (WHERE 절)
-- 사번, 이름, 급여 조회 (SELECT 절)
-- 단, 급여 내림 차순으로 조회 (ORDER BY 절)
SELECT EMP_ID, EMP_NAME, SALARY
FROM EMPLOYEE e WHERE SALARY >= 2000000 -- 여러 조건을 결합해 복잡한 필터링 가능
ORDER BY 3 DESC; -- 컬럼 순서


-- 입사일 순서대로 이름, 입사일 조회 (별칭 사용)
SELECT EMP_NAME 이름, HIRE_DATE 입사일
FROM EMPLOYEE;
ORDER BY 입사일;

/* 정렬 중첩 : 대분류 정렬 후 소분류 정렬*/
-- 부서코드 오름차순 정렬 후 급여 내림차순 정렬
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
ORDER BY DEPT_CODE, SALARY DESC; -- 결과를 정렬하는 방법

















